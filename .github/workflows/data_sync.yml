name: 'Minecraft Data Generator & Git Sync'

on:
  # Schedule the job to run daily at 03:00 UTC to check for new versions
  schedule:
    - cron: '0 3 * * *'
  # Allow manual execution via the GitHub Actions interface
  workflow_dispatch:

jobs:
  generate_and_sync:
    runs-on: ubuntu-latest
    
    # Permissions are needed for the actions/checkout step and later for pushing
    permissions:
      contents: write 

    steps:
      - name: 1. Setup Java 21 (Required for the Minecraft Data Generator JAR)
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: 2. Checkout Repository (using PAT for push access)
        # Use the PAT token from secrets for authentication on future pushes.
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history to check for existing remote branches
          token: ${{ secrets.GH_PAT }}

      - name: 3. Generator Logic (Bash Script)
        id: run_sync
        env:
          # Start processing from this version onwards (inclusive).
          START_VERSION: "1.21.10"
          MANIFEST_URL: "https://launchermeta.mojang.com/mc/game/version_manifest.json"
          GH_TOKEN: ${{ secrets.PAT }} # Token for pushing new branches
          REPO_URL: ${{ github.server_url }}/${{ github.repository }}

        run: |
          # --- CONSTANT SETUP ---
          REPO_DIR="."
          OUTPUT_DIR="minecraft_versions"
          
          # Embed the PAT into the Git URL for pushing new branches.
          AUTH_REPO_URL=$(echo "${REPO_URL}" | sed "s|https://|https://${GH_TOKEN}@|")

          echo "Lade Version Manifest..."
          MANIFEST=$(curl -s $MANIFEST_URL)
          
          # --- 1. Versionen filtern und in die korrekte Reihenfolge bringen (Alt -> Neu) ---
          
          echo "Suche den Index der START_VERSION ($START_VERSION)..."

          # Nutze jq, um den Index zu finden, an dem START_VERSION liegt.
          # Das Manifest ist chronologisch sortiert (Index 0 = neueste Version).
          START_INDEX=$(echo "$MANIFEST" | jq -r --arg start "$START_VERSION" '.versions | map(.id) | index($start)')
          
          if [ "$START_INDEX" == "null" ]; then
            echo "Fehler: Die angegebene START_VERSION ($START_VERSION) wurde im Versions-Manifest nicht gefunden. Synch wird abgebrochen."
            exit 0
          fi
          
          echo "START_VERSION ($START_VERSION) gefunden bei Index: $START_INDEX. Verarbeite ab dieser Version."
          
          # Wende die indexbasierte Logik an (Slice von 0 bis zum gefundenen Index, dann umkehren).
          # Das Ergebnis ist eine Liste der zu verarbeitenden Versionen, sortiert von Alt nach Neu.
          VERSIONS_JSON=$(echo "$MANIFEST" | jq -c --argjson start_index "$START_INDEX" '
            .versions 
            | .[0 : $start_index + 1]  # Slice von Index 0 bis zum START_INDEX (inklusive)
            | reverse                  # Kehrt die Reihenfolge um: jetzt von Alt nach Neu
            | .[]                      # Erzeugt einzelne Objekte für die Bash-Schleife
          ')

          if [ -z "$VERSIONS_JSON" ]; then
            echo "Keine neuen Versionen ab $START_VERSION gefunden."
            exit 0
          fi
          
          echo "Verarbeite Versionen ab $START_VERSION, von der ältesten zur neuesten..."
          PROCESSED_COUNT=0

          for VERSION_OBJECT in $VERSIONS_JSON; do
            VERSION_ID=$(echo "$VERSION_OBJECT" | jq -r '.id')
            VERSION_TYPE=$(echo "$VERSION_OBJECT" | jq -r '.type')
            VERSION_URL=$(echo "$VERSION_OBJECT" | jq -r '.url')
            
            # --- 2. Namen bereinigen und Branch-Namen erstellen ---
            
            # Ersetze Leerzeichen und Slashes durch Bindestriche für gültige Git-Namen.
            CLEAN_ID=$(echo "$VERSION_ID" | sed 's/[ /]/-/g')
            BRANCH_NAME="${VERSION_TYPE:0:1}-${CLEAN_ID}" # s- oder r- Präfix

            # Ordnername behält die Original-ID (mit Leerzeichen/Punkten)
            FOLDER_NAME="${VERSION_TYPE:0:1}-${VERSION_ID}"
            TEMP_FOLDER="$OUTPUT_DIR/$FOLDER_NAME"
            GENERATED_PATH="$TEMP_FOLDER/generated"

            echo -e "\n--- Prüfe Version: $VERSION_ID (Branch: $BRANCH_NAME) ---"
            
            # --- 3. Prüfen, ob Branch existiert ---
            if git ls-remote --exit-code origin "$BRANCH_NAME" > /dev/null 2>&1; then
              echo "Branch $BRANCH_NAME existiert bereits remote. Überspringe Generierung."
              continue
            fi
            
            # --- 4. Download und Generierung der Daten ---
            
            if [ ! -d "$GENERATED_PATH" ]; then
                echo "Fehlende Daten. Lade Manifest $VERSION_ID herunter..."
                
                VERSION_JSON=$(curl -s "$VERSION_URL")
                SERVER_JAR_URL=$(echo "$VERSION_JSON" | jq -r '.downloads.server.url')
                
                if [ "$SERVER_JAR_URL" == "null" ] || [ -z "$SERVER_JAR_URL" ]; then
                    echo "Keine Server-Version für $VERSION_ID gefunden. Überspringe."
                    continue
                fi
                
                mkdir -p "$TEMP_FOLDER"
                JAR_PATH="$TEMP_FOLDER/minecraft_server.jar"

                echo "Lade Server JAR: $SERVER_JAR_URL"
                curl -s -L "$SERVER_JAR_URL" -o "$JAR_PATH"

                echo "Führe Data Generator aus..."
                # FIX: Wechselt in den TEMP_FOLDER, damit 'generated' dort erstellt wird.
                pushd "$TEMP_FOLDER" > /dev/null
                java -DbundlerMainClass=net.minecraft.data.Main -jar ./minecraft_server.jar --all
                popd > /dev/null
                
                # --- DEBUGGING START ---
                echo "DEBUG: Inhalt von $TEMP_FOLDER nach Java-Ausführung:"
                ls -l "$TEMP_FOLDER"
                echo "DEBUG: Inhalt von $GENERATED_PATH vor Kopieren:"
                # Verwende || true, um sicherzustellen, dass das Skript nicht abbricht, falls der Ordner nicht existiert.
                ls -l "$GENERATED_PATH" || true
                # --- DEBUGGING END ---

            else
                echo "Daten existieren bereits in $GENERATED_PATH. Überspringe Download/Generierung."
            fi

            # --- 5. Git-Operationen (Branch erstellen, Kopieren, Commit) ---
            
            # Neuen Branch erstellen und darauf wechseln
            git branch "$BRANCH_NAME" || true
            git checkout "$BRANCH_NAME"
            
            # B. Verzeichnis säubern (alles außer .git und .github)
            echo "Bereinige Arbeitsverzeichnis..."
            find "$REPO_DIR" -maxdepth 1 -not -path "$REPO_DIR" -not -name ".git" -not -name ".github" -exec rm -rf {} +

            # C. Inhalt von "generated" in das Repo-Wurzelverzeichnis kopieren
            echo "Kopiere Daten von $GENERATED_PATH nach $REPO_DIR"
            # Fügt auch versteckte Dateien/Ordner hinzu, falls vorhanden
            # Der Fehler tritt hier auf, wenn der Pfad leer ist.
            cp -r "$GENERATED_PATH/"* "$REPO_DIR"
            
            # D. Commit und Push
            git add -A
            COMMIT_MSG="Update to $VERSION_ID"
            
            if git commit -m "$COMMIT_MSG"; then
              echo "Pushe Branch $BRANCH_NAME zu Remote..."
              git push "$AUTH_REPO_URL" "$BRANCH_NAME"
              PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
            else
              echo "Keine Änderungen für $VERSION_ID gefunden (kein Commit/Push)."
            fi
            
            # WICHTIG: Zurückwechseln zum main-Branch für den nächsten Schleifendurchlauf
            git checkout main || git checkout master || echo "Could not switch back to main/master branch."

          done # Ende der Versionsschleife
          
          echo -e "\n*** Synchonisation abgeschlossen. ${PROCESSED_COUNT} neue Branches gepusht. ***"
